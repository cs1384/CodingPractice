Good quesitons:

lc041_First_Missing_Positive
lc114_Flatten_Binary_Tree_to_Linked_List
lc126_Word_Ladder_II
lc137_Single_Number_II

1. two pointer

Sorted array to find a sum -> two pointers from head and rear, this will take O(N) instead of O(NlogN) which is to
fix on an index and binary search for the corresponding index

ex. lc001_two_sum, lc011_Container_With_Most_Water

2. String comparison (even to itself) -> DP

ex. lc005_Longest_Palindromic_Substring

3. How to check integer boundary

if(res<0 && Integer.MIN_VALUE/10>res) return 0;
if(res>0 && Integer.MAX_VALUE/10<res) return 0;

ex. lc007_Reverse_Integer

4. get all results -> DFS

5. linked list fixed distance -> fast and slow pointer

6. ascending to descending order -> reverse

ex. lc031_Next_Permutation

7. solve in place -> need to know the position of holding element

8. no duplicate -> sort the array

ex. lc047_Permutations_II

9. ArrayList removes last faster than LinkedList

Because ArrayList accesses last index faster. LinkedList needs
to go along way through to the last. Only iterator has that linked list
advantage.

10. permutation, combination, set

ex. lc046_Permutations, lc077_Combinations, lc078_Subsets.

11. when swapping index in an array, think of where it goes!

12. when parseInt(), notice that the "0000" will be parsed to 0

ex. lc091_Decode_Ways, lc093_Restore_IP_Addresses

13. Use double ended BFS when there are start and end points

ex. lc127_Word_Ladder

14. Use Trie to make DFS(backtracking) more efficient

ex. lc212_Word_Search_II

